OSIV (Open Session In View)

영속성 컨텍스트를 뷰까지 열어두겠다 라는 의미로 영속성 컨텍스트가 살아있으면, 
엔티티는 영속 상태로 관리되기 때문에 지연 로딩을 사용 할 수 있다.

이전의 요청당 트랜잭션 방식의 osiv는 프리젠테이션 계층(뷰, 컨트롤러)에서 데이터 변경이 가능햇으나
스프링 프레임워크의 osiv는 그런 문제점을 어느정도 해결하여 비즈니스 계층(service,repository)에서 트랜잭션을 사용한다. 

스프링 OSIV를 사용하면 프리젠테이션 계층에서 엔티티를 수정해도 수정 내용을 데이터베이스에 반영하지 않는다
비즈니스 계층까지 와야 트랜잭션AOP가 동작하면서 영속성 컨텍스트를 플러시 한다. 
이때 변경 감지가 동작되며 수정사항을 데이터베이스에 반영한다. 



OSIV를 사용하면 같은 영속성 컨텍스트를 여러 트랜잭션이 공유
프리젠테이션 계층에서 엔티티를 수정하고 난 후 비즈니스 로직을 수행하면 엔티티가 수정될 수 있다
실시간 트레픽이 중요한 경우 OSIV를 사용하지 말고, DTO로 직접 조회를 권장한다. 
------------------------
OSIV 개념 다시 잡기 다음주까지


서비스 계층이 끝나면 트랜잭션을 커밋하고 영속성 컨텍스트를 플러시한다. 이때 트랜잭션은 끝내지만 영속성 컨텍스트는 종료하지 않는다.
컨트롤러와 뷰까지 영속성 컨텍스트가 유지되므로 조회한 엔티티는 영속성 상태를 유지한다.
서블릿 필터나 스프링 인터셉터(컨트롤러(Controller)의 '핸들러(Handler)'를 호출하기 전과 후에 요청과 응답을 참조하거나 가공할수 있는 일종의 필터)로 요청이 돌아오면 영속성 컨텍스트를 종료한다. 이때 플러시를 호출하지 않고 바로 종료한다.
 
프리젠테이션 계층에서 플러시
트랜잭션을 사용하는 서비스 계층이 끝날 때 트랜잭션이 커밋되면서 이미 플러시해버렸다. 그리고 스프링이 제공하는 OSIV 서블릿 필터나 OSIV 스프링 인터셉터는 요청이 끝나면 플러시를 호출하지 않고 em.close()로 영속성 컨텍스트만 종료해 버리므로 플러시가 일어나지 않는다.
프레젠테이션 계층에서 em.flush()로 강제로 플러시해도 트랜잭션 범위 밖이므로 데이터를 수정할 수 없다는 TransactionRequireException 예외가 발생한다.


동시 접속 유저가 많아질수록 커넥션 풀이 넉넉해야 TPS가 높아진다. 
하지만 OSIV 전략을 사용하면 커넥션을 효율적으로 사용하지 못하게 된다.
 왜냐하면 JPA 영속성 컨텍스트는 DB와 1:1로 연결되어 커넥션 하나를 종료될 때 까지 계속 사용하기 때문

트랜잭션을 시작할 때 영속성 컨텍스트가 DB 커넥션을 가져온다. 
커넥션의 생명은 영속성 컨텍스트가 종료될 때까지 유지된다. 
즉, 스프링 OSIV 전략을 사용하면 API 응답이 끝날 때까지 유지하게 된다. 
왜냐하면 트랜잭션이 끝나더라도 지연 로딩으로 프록시 객체를 초기화할 상황이 생기기 때문이다. 따라서 영속성 컨텍스트가 DB 커넥션을 계속 물고 있어야 한다.
 컨트롤러에서 외부 API를 호출하면 외부 API대기 시간 만큼 커넥션 리소스를 반환하지 못하고, 유지

OSIV전략은 트랜잭션 시작처럼 최초 데이터베이스 커넥션 시작 시점부터 API 응답이 끝날 때까지 영속성 컨텍스트와 데이터베이스 커넥션을 유지


https://ppomelo.tistory.com/154