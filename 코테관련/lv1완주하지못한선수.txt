
수많은 마라톤 선수들이 마라톤에 참여하였습니다. 단 한 명의 선수를 제외하고는 모든 선수가 마라톤을 완주하였습니다.

마라톤에 참여한 선수들의 이름이 담긴 배열 participant와 완주한 선수들의 이름이 담긴 배열 completion이 주어질 때, 
완주하지 못한 선수의 이름을 return 하도록 solution 함수를 작성해주세요.

--------------------HashMap이용버전-----------------------
import java.util.HashMap;

class Solution {
    public String solution(String[] participant, String[] completion) {
        String answer = "";
        HashMap<String, Integer> hm = new HashMap<>(); //해쉬맵을 이용하여 순서대로 값을 넣어줄 예정
        // 참가인원을 해쉬맵에 담아준다. 이때 동명이인이 있을수 있는 조건때문에 getOrDefault함수를 이용하여 인원수를 기본 0으로 해주고 값이 있으면 1을 증가시켜준다.
        for (String player : participant) hm.put(player, hm.getOrDefault(player, 0) + 1);
        // 완주한 인원은 해쉬맵에서 -1 해주어 통과하지 못한 인원을 찾는다.
        for (String player : completion) hm.put(player, hm.get(player) - 1);

        // 해쉬맵에서 값을 찾는다. 0인경우는 해당 이름이 모두 통과한경우 이다. 1 일경우 통과하지 못함.
        for (String key : hm.keySet()) {
            if (hm.get(key) != 0){
                answer = key;
            }
        }
        return answer;
    }
}

--------------------------list 정렬 이용버전----------------------------------
import java.util.*;
class Solution {
    public String solution(String[] participant, String[] completion) {
        // Arrays.sort로 정렬해준다. 여러명을 찾는게 아니라 한명만 찾는것이기 때문에 정렬해서 다른것을 찾으면 된다.
        Arrays.sort(participant);
        Arrays.sort(completion);
        //i 값이 for문 외부에 있는 이유는 return 값으로 넘겨줄때 i를 이용하기 위함. 
        // if문안에서 answer = raticipant[i];를 사용해도 됨.
        int i;
        for ( i=0; i<completion.length; i++){
            // 순서대로 실행하였을때 다른 값이 나온다면 등록된 인원중 없는 인원이기 때문에 해당 인원을 return해준다.
            if (!participant[i].equals(completion[i])){
                return participant[i];
            }
        }
        return participant[i];
    }
}
