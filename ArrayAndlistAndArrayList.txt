

Array(배열)
    - 여러 데이터를 하나의 이름으로 그룹핑해서 관리 하기 위한 자료구조. index와 값의 쌍으로 구성
    논리적 저장 순서와 물리적 저장 순서가 일치 => index로 해당 원소에 접근할 수 있다. (O(1))
    연속된 메모리의 공간으로 이루어져 있다
    배열은 정의와 동시에 길이를 지정하며 길이를 바꿀 수 없다. 정적이므로 배열의 크기를 컴파일 이전에 정해주어야 한다.
    javascript 
        // 서로 다른 데이터 타입을 담을 수 있다
        var arr = [1234, 'test', true];    
    java 
        int[] odds = {1, 3, 5, 7, 9}; 

List
    순서가 있는 엘리먼트의 모임으로 배열과는 다르게 빈 엘리먼트는 절대 허용하지 않는다.
    빈 엘리먼트는 허용하지 않는다. => java에서는 허용하는 경우가 있음
    크기를 동적으로 늘릴 수 있다
    배열에서 인덱스는 유일무이한 식별자이지만 리스트에서는 몇 번째 데이터인지 정도의 의미


ArrayList
    일반 배열과 ArrayList는 인덱스로 객체를 관리한다는 점에서 동일하지만, 크기를 동적으로 늘릴 수 있다는 점에서 차이
    내부에서 처음 설정한 저장 용량(capacity)가 있다. 설정한 저장 용량 크기를 넘어서 더 많은 객체가 들어오게 되면, 배열 크기를 1.5배로 증가
    ArrayList에서 특정 인덱스의 객체를 제거하게 되면, 제거한 객체의 인덱스부터 마지막 인덱스까지 모두 앞으로 1칸씩 앞으로 이동한다. 
    객체를 추가하게 되면 1칸씩 뒤로 이동하게 된다. 인덱스 값을 유지하기 위해서 전체 객체가 위치가 이동

LinkedList
    연결로 구현한 리스트
    한 원소에서 값과 다음 원소의 주소를 알고 연결하는 방식
    배열과 다르게 논리적 저장 순서와 물리적 저장 순서가 일치하지 않는다


List에는 ArrayList, Vector, LinkedList 등의 List 인터페이스를 구현한 자료형이 있다.
즉, List 인터페이스 안에 ArrayList 클래스가 있다.

List list = new ArrayList();
-> 도형 list = new 정사각형();

ArrayList list = new ArrayList();
-> 정사각형 list = new 정사각형();

두개가 같은 결과이지만 list로 만든것이 유연성에 있어서 유리하다. 
 ArrayList<Object> list = new ArrayList<>(); 와 같이 ArrayList라는 인스턴스로 선언하면,
나중에 데이터의 용도가 바뀌어 삽입/삭제가 유리한 LinkedList 자료구조로 변경해야 할 때 ArrayList로 선언된 모든 부분을 LinkedList로 변경해 주어야 한다.
또, ArrayList에서는 지원하지만 LinkedList에서는 지원하지 않는 메소드를 사용했다면 그 메소드를 더 이상 사용할 수 없게 된다.


배열은 Compile time에 할당되는 정적 메모리 할당, 리스트는 새로운 Node(데이터 지점data point)가 추가되는 runtime에 할당되는 동적 메모리 할당

런타임 : 컴파일 과정을 마친 응용 프로그램이 사용자에 의해 실행될 때 
컴파일 타임 : 소스 코드가 컴파일을 통해 기계어 코드로 변환되어 실행 가능한 프로그램이 되는 편집 과정

----------------------------------------------------------------------------------------------------------------------------------

배열 [], 혹은 객체 {} 

인터페이스는 타입이며 컴파일 후에 사라진다. 추상 클래스는 선언과 구현이 모두 존재하지만 인터페이스는 선언만 존재하며, 
멤버 변수와 멤버 메서드를 선언할 수 있지만 접근 제한자는 설정할 수 없습니다.
클래스와 달리 interface는 TypeScript의 컨텍스트 내에서만 존재하는 가상 구조입니다. 
TypeScript 컴파일러는 타입 체크 목적으로만 인터페이스를 사용합니다. 코드가 JavaScript 언어로 트랜스 파일되면 인터페이스에서 제거됩니다.
추상클래스로 사용됩니다. 메소드의 형태만 선언해서 인터페이스를 정의하고, 이후에 클래스를 정의할 때 implements 키워드를 사용하면서 이 인터페이스를 지정하면, 
이 클래스는 추상함수로 선언된 메소드의 몸체를 받아들여야 합니다.

객체지향 프로그래밍은 커다란 문제를 클래스라는 단위로 나누고 클래스 간의 관계를 추가하면서 코드 중복을 최소화하는 개발 방식입니다. 
클래스는 객체지향 프로그래밍 그 자체이며 클래스 간의 관계는 상속이나 포함 관계를 고려해 추가합니다.
객체 팩토리로 사용됩니다. Class는 객체의 모양과 동작에 대한 청사진을 정의한 다음 클래스 속성을 초기화하고 method를 정의합니다. 
따라서 클래스의 인스턴스를 만들 때 실행 가능한 함수와 정의된 property를 가진 객체를 얻습니다.




