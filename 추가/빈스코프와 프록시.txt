 빈 스코프와 프록시
        싱글톤 scope를 가진 bean은 스프링이 올라가는 시점부터 스프링컨테이너가 종료되는 순간까지 살아있다.
        request scope를 가진 bean은 고객의 request가 발생한 시점부터 response가 나갈 때까지 살아있다.
        prototype scope를 가진 빈은 스프링 컨테이너에게 요청하는 시점에 생성+의존관계주입+초기화 되고 반환된다.
        싱글톤 scope bean은 스프링이 올라가는 시점에 객체가 생성되고, 의존관계가 주입된다.
        근데 싱글톤 scope bean에 request scope 빈을 주입해달라고 코딩하면, 싱글톤 빈이 생성되는 시점에는 고객의 request가 없어서 request scope bean이 존재하지 않기 때문에 의존관계 주입 오류가 발생한다.
        이러한 스코프의 차이로 인해서 bean들간의 의존관계 주입이 제약을 받게 된다.
        이때는 첫번째 방법은 스프링 컨테이너 자체를 주입받아서, 스프링 컨테이너에게 스코프가 다른 빈을 조회하는 방법이 있다.
        두번쨰 방법은 DL 개념이 적용된 Provider 사용하여, 실제 빈이 필요한 시점에 스프링 컨테이너에 bean을 검색해서 받아서 쓰는 방법이다.
        세번째 방법은 request scope bean을 사용/검색할 수 있는, 싱글톤 스코프의 프록시 bean을 등록하여 프록시 빈을 통해 사용하는 것이다.
        Provider라는 개념도 request scope bean을 조회할 수 있는 싱글톤 빈이지만, 
        프록시처럼 대상이 되는 빈을 상속받고 그 빈을 대체하여 주입되지는 않는, 단순 스프링 컨테이너 조회용 싱글톤 빈이다. 
        결국 프록시라는 것은 스프링 빈 간의 스코프의 차이를 극복하기 위한 것이다.
        스프링이 의존관계를 조립하는 시점과 실제 bean을 생성/사용될 수 있는 시점의 차이가 있고, 
        이런 경우에 request scope 빈이나 prototype 빈을 사용하기 위한 중간다리 개념이 프록시인 것이다. 
        
        결국 프록시의 싱글톤이 아닌 빈이 실제로 생성/사용되는 순간까지 지연시키는 것이며,
        스프링이 구동하는 의존관계 주입 시점에 그 실제 빈이 존재하지 않으니, 그 빈을 상속한 싱글톤 프록시 객체를 대신 등록/주입하는 것이다.
        프록시 객체는 싱글톤이기 때문에 스프링 구동초기 의존관계 주입 시점에 생성되어, 의존관계를 오류없이 주입할 수 있다. 
        이처럼 스코프다 다른 빈을 싱글톤 빈처럼 사용하기 위한 개념이 프록시인 것이다.